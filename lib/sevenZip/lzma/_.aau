import fsys;
namespace sevenZip.lzma;

var ERRORMESSAGE = {
	[ 1/*_SZ_ERROR_DATA*/ ] = "数据错误";
	[ 2/*_SZ_ERROR_MEM*/ ] = "分配内存失败";
	[ 6/*SZ_ERROR_INPUT_EOF*/ ] = "输入溢出";
	[ 7/*SZ_ERROR_OUTPUT_EOF*/ ] = "输出溢出";
	[ 8/*_SZ_ERROR_READ*/ ] = "读输入文件失败"; 
	[ 9/*_SZ_ERROR_WRITE*/ ] = "写输出文件失败";
}

decodeFile = function(inFile,outFile,progress){
	inFile = ..io.exist(inFile);
	if(!inFile) return null,"打开输入文件失败"
	
	outFile = outFile ? ..io.fullpath(outFile);
	if(!..fsys.createParentDir(outFile)) return null,"打开输入文件失败"
	
	var progress_c;
	if( progress ){
		progress_c = ..raw.tocdecl(progress,"int( INT inProcessed,INT outProcessed)");  
	}
	var ret  = lzmafile(inFile,outFile,progress_c,false);
	if( ret ) return false,ERRORMESSAGE[ret]
	return true;
} 

encodeFile = function(inFile,outFile,progress){
	inFile = ..io.exist(inFile);
	if(!inFile) return null,"读输入文件失败"
	
	outFile = outFile ? ..io.fullpath(outFile);
	if(!..fsys.createParentDir(outFile)) return null,"写输出文件失败"	
	
	var progress_c;
	if( progress ){
		progress_c = ..raw.tocdecl(function(p,inSize,outSize){
			return progress( inSize,outSize );
		},"int(pointer,LONG,LONG)");
	}
	var ret  = lzmafile(inFile,outFile,progress_c,true);
	if( ret ) return false,ERRORMESSAGE[ret]
}

class LZMA_HEADER {
	BYTE properties[5];
	LONG uncompressedSize; 
}

compress = function( src,level=5,dictSize=0x1000000,numThreads=2, lc=3,lp=0,pb=2,fb=32){
	var srcLen = #src;
	var header = LZMA_HEADER(); 
	var propSize = 5;
	
	var dest = ..raw.malloc( ( srcLen * 2) + 5 ,0);
	var destLen = #dest;
 
	var ret,destLen,propSize = LzmaCompress(dest,destLen,src,srcLen,header,5,level, dictSize, lc,lp,pb,fb,numThreads);
	if(  ret == 7/*_SZ_ERROR_OUTPUT_EOF*/ ) {
		destLen = destLen *2;
		dest = ..raw.malloc( destLen );
		ret,destLen = LzmaCompress(dest,destLen,src,srcLen,prop,propSize,level, dictSize, lc,lp,pb,fb,numThreads); 
	}

	if( ret ) return false,ret;  
	header.uncompressedSize = srcLen;

	return header,..raw.tostring(dest,1,destLen);
}

unCompress = function( src,header ){
	var srcLen = #src;
	var destLen = header.uncompressedSize;
	if( (!destLen) or ( destLen < 0 ) ) destLen = srcLen*50;
	var dest = ..raw.malloc( destLen); 
	var ret,destLen = LzmaUncompress(dest,destLen,src,srcLen,header,5);  
	
	if( ret && ret!=6/*SZ_ERROR_INPUT_EOF*/) return false,ret; 
	return ..raw.tostring(dest,1,destLen);
}

_dll = ..raw.loadDll( $"~/lib/sevenZip/lzma/.res/LzmaUtil.dll","sevenZip.LzmaUtil.dll")
lzmafile = _dll.api("lzmafile","int(string  in_path,string out_path,pointer progress,bool encodeMode)" ,"cdecl") 
LzmaCompress = _dll.api("LzmaCompress","int(pointer dest,INT &destLen,pointer src,INT srcLen,struct &outProps, INT &outPropsSize,int level, INT dictSize,int lc,int lp,int pb,int fb, int numThreads )" ,"cdecl") 
LzmaUncompress = _dll.api("LzmaUncompress","int(pointer dest,INT &destLen, pointer src,INT &srcLen, struct props, INT propsSize)" ,"cdecl") 
 
/**intellisense(sevenZip.lzma)
decodeFile(.(输入文件路径,输出文件路径,进度回调函数) = 解压文件,可选指定进回调函数\nfunction(inProcessed,outProcessed){ }
encodeFile(.(输入文件路径,输出文件路径,进度回调函数) = 压缩文件,可选指定进回调函数\nfunction(inSize,outSize){ }
compress(.(待压缩数据,压缩级别,字典大小,线程数,lc,lp,pb,fb) = 压缩字符串,除参数一以外其他参数可选,\n成功返回两个值:lzmaHeaer,lzmaData,\nlzmaHeaer为LZMA压缩头,lzmaData为压缩后字符串\n失败返回false,以及错误代码
unCompress(.(待解压数据,LZMA头) = 解压字符串
compress() = !SEVERZIP_LZMA_HEADER.
end intellisense**/

/**intellisense(!SEVERZIP_LZMA_HEADER) 
properties = 记录压缩参数,\n该值为(pb * 5 + lp) * 9 + lc
uncompressedSize = 文件原始大小
end intellisense**/